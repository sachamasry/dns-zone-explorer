<!-- livebook:{"autosave_interval_s":60} -->

# DNS Zone Explorer

```elixir
Mix.install([
  {:kino, "~> 0.12.3"},
  {:kino_shell, "~> 0.1.2"},
  {:jason, "~> 1.4"},
  {:domainname, "~> 0.1.5"},
  {:whois, "~> 0.2.1"}
])
```

## Domain entry, parsing and querying

To begin, we need user input to know which domain to interrogate, saving the input into the `domain` variable.

```elixir
domain = Kino.Input.text("Enter your domain name")
```

The following will read and attempt to construct a valid domain name and parrot the user input back to us, as a simple form of feedback. If it fails, then an error will warn us of this at this stage.

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
{:ok, verified_domain} =
  DomainName.new(Kino.Input.read(domain),
    must_be_hostname: true
  )
```

```elixir
defmodule DomainNameQuerying do
  def domain_name_query(domain_name) do
    domain_name
    |> DomainName.name()
    |> Whois.lookup()
  end

  def get_critical_domain_info(domain_name) do
    case domain_name_query(domain_name) do
      {:ok,
       %Whois.Record{
         registrar: registrar,
         created_at: created_at,
         updated_at: updated_at,
         expires_at: expires_at
       }} ->
        %{
          registrar: registrar,
          created_at: created_at,
          updated_at: updated_at,
          expires_at: expires_at
        }

      {_, _} ->
        {:error}
    end
  end
end
```

## Defining special variables

Email authentication is a collection of techniques aimed at providing verifiable information about the origin of email messages. Three authentication methods have been widely adopted: DKIM, SPF and DMARC. DKIM and DMARC are specified as DNS records, using specific _subdomain labels_, which we define in this section.

BIMI is a branding specification, and as it is bound to be more widely used, we will specify its own subdomain label requirement as well.

```elixir
dkim_subdomain_label = "_domainkey"
dmarc_subdomain_label = "_dmarc"
bimi_subdomain_label = "_bimi"
```

Let's define a set of DKIM selectors in `dkim_selector_list`, as a valid selector is needed to query for a DKIM key.

```elixir
known_dkim_selector_list = [
  # Generic
  "x",
  # Google
  "google",
  # Microsoft
  "selector1",
  # Microsoft
  "selector2",
  # MailChimp
  "k1",
  # Mandrill
  "mandrill",
  # Everlytic
  "everlytickey1",
  # Everlytic
  "everlytickey2",
  # Hetzner
  "dkim",
  # MxVault 
  "mxvault",
  # MailJet
  "mailjet",
  # Avoccado.ai
  "pic"
]
```

Let's get locations of all subdomain enumeration tools we may need, into variables we can use.

```elixir
amass_binary = System.get_env("LB_AMASS_BIN")
assetfinder_binary = System.get_env("LB_ASSETFINDER_BIN")
dnsrecon_binary = System.get_env("LB_DNSRECON_BIN")
puredns_binary = System.get_env("LB_PUREDNS_BIN")
subfinder_binary = System.get_env("LB_SUBFINDER_BIN")
sublist3r_binary = System.get_env("LB_SUBLIST3R_BIN")
dss_binary = System.get_env("LB_DSS_BIN")
:ok
```

## Using Erlang's :inet_res builtin functionality

```elixir
defmodule Dns.Query do
  def get_record_info(dns_name, type) when is_atom(type) do
    dns_name
    |> DomainName.name()
    |> String.to_charlist()
    |> :inet_res.resolve(:in, type)
    |> case do
      {:ok, res} ->
        {:ok,
         res
         |> :inet_dns.msg()
         |> Keyword.fetch!(:anlist)
         |> Enum.map(fn i -> Enum.into(:inet_dns.rr(i), %{}) end)
         |> Enum.map(fn i ->
           Map.merge(i, %{
             query_tool: "inet_res",
             answer_source: "#{String.upcase(Kernel.to_string(type))} query"
           })
         end)}

      {:error, reason} ->
        {:error, reason}
    end
  end

  def filter_for_matching_type(response, type) do
    case response do
      {:ok, msg} ->
        msg
        |> Enum.reverse()
        |> case do
          [%{type: ^type} | _tail] -> msg
          _ -> []
        end

      {:error, _} ->
        []
    end
  end

  def get_a_records(fqdn) do
    get_record_info(fqdn, :a) |> filter_for_matching_type(:a)
  end

  def get_aaaa_records(fqdn) do
    get_record_info(fqdn, :aaaa) |> filter_for_matching_type(:aaaa)
  end

  def get_cname_record(fqdn) do
    get_record_info(fqdn, :cname) |> filter_for_matching_type(:cname)
  end

  def resolves_to_already_seen?(record_list, domains_seen)
      when is_list(record_list) and is_list(domains_seen) do
    Enum.map(record_list, fn rec ->
      Enum.map(domains_seen, fn domain ->
        rec.data
        |> DomainName.new!()
        |> DomainName.equal?(domain)
      end)
    end)
    |> List.flatten()
    |> Enum.any?(fn i -> i end)
  end

  def get_ns_records(fqdn) do
    get_record_info(fqdn, :ns) |> filter_for_matching_type(:ns)
  end

  def get_mx_records(fqdn) do
    get_record_info(fqdn, :mx) |> filter_for_matching_type(:mx)
  end

  def get_ptr_records(fqdn) do
    get_record_info(fqdn, :ptr) |> filter_for_matching_type(:ptr)
  end

  def get_soa_records(fqdn) do
    get_record_info(fqdn, :soa) |> filter_for_matching_type(:soa)
  end

  def get_txt_records(fqdn) do
    get_record_info(fqdn, :txt) |> filter_for_matching_type(:txt)
  end

  def get_dmarc_record(fqdn, dmarc_subdomain_label) do
    construct_subdomain_host(fqdn, dmarc_subdomain_label)
    |> get_record_info(:txt)
    |> filter_for_matching_type(:txt)
  end

  def construct_subdomain_host(fqdn, subdomain_label),
    do: DomainName.join!(subdomain_label, fqdn)

  def get_dkim_records(fqdn, dkim_subdomain_label, selector_list)
      when is_list(selector_list) do
    dkim_subdomain = construct_subdomain_host(fqdn, dkim_subdomain_label)

    Enum.map(selector_list, fn sel ->
      get_record_info(
        construct_subdomain_host(dkim_subdomain, sel),
        :txt
      )
    end)
    # |> filter_for_matching_type(:txt)
    |> Enum.filter(fn
      {:error, _} -> false
      _ -> true
    end)
  end
end
```

As any record query may return a `CNAME`—or a _canonical name_—response, which the client will immediately query all the way until it encounters a non-CNAME response, we will receive a response list. This possibility needs to be checked, as it means getting multiple answer records, and this needs to be handled appropriately.

Two ways present themselves, the quick one being to discard all but the last record in the list, as this is likely to be the final one, and the one we actually want. Doing this, however, means eliding potentially useful information, at least for debugging, as it would not be clear how we came to the final record, without seeing the alias traversals within. In cases of DNS cache poisoning, or even Man-in-the-Middle (MITM) attacks, discovering unexpected `CNAME` records is critical in helping spot vulnerabilities, so they should be kept and reported on for a full picture of the state of the zone. Showing the full redirection picture aids in upholding the _principle of least astonishment_, in that it shouldn't cause surprise or consternation to systems administrators, or those developers who are not aware of every infrastructure decision taken to date.

## On DNS zone enumeration

For security reasons, it is difficult to get a true state of a DNS zone, as this is information which would be used by attackers in finding exploits.

To enumerate subdomains of a domain, we will turn to several penetration testing tools.

## Subdomain enumeration

We now call out to `System.cmd` to run `subfinder` on our domain. Note that ease of parsing is most important here, thus the tool is run with a few additional options:

* `-silent` so that the masthead message, progress and other messages are not printed to `stdout`
* `-json` to return a list of JSON-formatted results, for each enumerated subdomain
* `-active` to display active subdomains only

**PLEASE NOTE** This command is run on the network, querying multiple internet sources, and as such is likely to take some time, typically needing 30 seconds or more. Please be patient and don't interrupt it unnecessarily. For additional informative use, `stderr` has been redirected to `stdout` to show error messages, if any.

```elixir
# {subfinder_query_result, 0} =
#   System.cmd(
#     "bash",
#     ["-lc", "#{subfinder_binary} -d #{DomainName.name(verified_domain)} -silent -json -active"],
#     stderr_to_stdout: true
#   )

subfinder_query_result =
  {"{\"host\":\"api.magicpillsmovie.com\",\"input\":\"magicpillsmovie.com\",\"source\":\"leakix\"}\n{\"host\":\"school.magicpillsmovie.com\",\"input\":\"magicpillsmovie.com\",\"source\":\"leakix\"}\n{\"host\":\"magicpillsmovie.com\",\"input\":\"magicpillsmovie.com\",\"source\":\"digitorus\"}\n{\"host\":\"watch.magicpillsmovie.com\",\"input\":\"magicpillsmovie.com\",\"source\":\"hackertarget\"}\n{\"host\":\"email.reply.magicpillsmovie.com\",\"input\":\"magicpillsmovie.com\",\"source\":\"leakix\"}\n{\"host\":\"www.magicpillsmovie.com\",\"input\":\"magicpillsmovie.com\",\"source\":\"leakix\"}\n{\"host\":\"go.magicpillsmovie.com\",\"input\":\"magicpillsmovie.com\",\"source\":\"leakix\"}\n",
   0}
```

With query results saved to `subfinder_query_results`, we now need to clean up the results by splitting away newline characters (`\n`), filtering out empty strings, and parsing the JSON results.

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
# enumerated_subdomains =
#   subfinder_query_result
#   |> String.split("\n")
#   |> Enum.filter(fn rec -> rec != "" end)
#   |> Enum.map(fn rec -> Jason.decode!(rec) end)
#   |> Enum.map(fn m ->
#     m
#     |> Map.new(fn {k, v} -> {String.to_atom(k), v} end)
#     |> Map.merge(%{tool: "subfinder"})
#   end)
#   |> Enum.filter(fn %{host: host} -> host != DomainName.name(verified_domain) end)

enumerated_subdomains = [
  %{
    input: "magicpillsmovie.com",
    host: "api.magicpillsmovie.com",
    source: "leakix",
    tool: "subfinder"
  },
  %{
    input: "magicpillsmovie.com",
    host: "school.magicpillsmovie.com",
    source: "leakix",
    tool: "subfinder"
  },
  %{
    input: "magicpillsmovie.com",
    host: "watch.magicpillsmovie.com",
    source: "hackertarget",
    tool: "subfinder"
  },
  %{
    input: "magicpillsmovie.com",
    host: "email.reply.magicpillsmovie.com",
    source: "leakix",
    tool: "subfinder"
  },
  %{
    input: "magicpillsmovie.com",
    host: "www.magicpillsmovie.com",
    source: "leakix",
    tool: "subfinder"
  },
  %{
    input: "magicpillsmovie.com",
    host: "go.magicpillsmovie.com",
    source: "leakix",
    tool: "subfinder"
  }
]
```

```elixir
defmodule Dns.Core do
  def get_host_name_without_domain(parent_domain, host) do
    DomainName.new!(host)
    |> DomainName.without_suffix(parent_domain)
    |> case do
      {:ok, name} -> name
      {:error, _} -> host
    end
  end

  def get_subdomain_labels(host) do
    DomainName.labels(host) |> Enum.reverse()
  end

  def classify_txt_record_type(record) do
    data_string = Enum.join(record.data)
    spf_re = ~r/^v=spf1.*/

    cond do
      String.match?(data_string, spf_re) -> "SPF"
      true -> ""
    end
  end

  def handle_record_payload(payload) do
    case payload do
      {:ok, []} ->
        []

      {:ok, payload} ->
        payload |> Enum.with_index(fn rec, index -> Map.merge(rec, %{id: index + 1}) end)

      {:error, _} ->
        []

      [ok: []] ->
        []

      [ok: payload] ->
        payload |> Enum.with_index(fn rec, index -> Map.merge(rec, %{id: index + 1}) end)

      [error: _] ->
        []

      record_list when is_list(record_list) ->
        record_list |> Enum.with_index(fn rec, index -> Map.merge(rec, %{id: index + 1}) end)

      [] ->
        []
    end
  end

  def handle_soa_record_data({mname, rname, serial, refresh, retry, expire, minimum} = data)
      when is_tuple(data) do
    %{
      mname: mname,
      rname: rname,
      serial: serial,
      refresh: refresh,
      retry: retry,
      expire: expire,
      minimum: minimum
    }
  end

  def handle_mx_record_data({priority, remaining_data} = data) when is_tuple(data) do
    %{priority: priority, data: remaining_data}
  end

  def handle_record_data(data) when is_tuple(data) do
    data
    |> Tuple.to_list()
    |> Enum.join(".")
  end

  def handle_record_data(data), do: Kernel.to_string(data)
end
```

## Get DKIM, DMARC and SPF records

```elixir
# {dss_domain_scan, 0} =
#   System.cmd(
#     "bash",
#     [
#       "-lc",
#       "#{dss_binary} scan #{DomainName.name(verified_domain)} --advise --checkTls --format json"
#     ],
#     stderr_to_stdout: true
#   )

{dss_domain_scan, 0} =
  {"{\"scanResult\":{\"domain\":\"magicpillsmovie.com\",\"elapsed\":1422,\"dkim\":\"v=DKIM1; k=rsa; p=MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA1QuexI9cwivkCoREvb6obK6BjbNnY4j/oqkEHZQSwyojtVL1EMjcuDk5vobxnIq+jsbhJjkm3CSA9KHDcberkxxXliewzdxF77QAbUvdU5eNxexEcXdGMsrjnCevlg4k4Kjcrq0Htw+R9jFMM52lW4eJ3pnCsG1Cf9JOK73T9iN1UIOin6E0I2y/1KHsWwXv2fm0Sb7A6PRUoYSCdKITPQV2U6Dz2kusvzB94mA5bVdzCbwhzZ6DpUzmy1PlNWbXBodyZIwoFKoUJ1GpWoUTVhZ97c3aHZ4O1LQwX571o/KZgagurzX9vkmegT6GsOL3BLI46kktHgt3iA3C5oKdKwIDAQABv=DKIM1; k=rsa; p=MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA1QuexI9cwivkCoREvb6obK6BjbNnY4j/oqkEHZQSwyojtVL1EMjcuDk5vobxnIq+jsbhJjkm3CSA9KHDcberkxxXliewzdxF77QAbUvdU5eNxexEcXdGMsrjnCevlg4k4Kjcrq0Htw+R9jFMM52lW4eJ3pnCsG1Cf9JOK73T9iN1UIOin6E0I2y/1KHsWwXv2fm0Sb7A6PRUoYSCdKITPQV2U6Dz2kusvzB94mA5bVdzCbwhzZ6DpUzmy1PlNWbXBodyZIwoFKoUJ1GpWoUTVhZ97c3aHZ4O1LQwX571o/KZgagurzX9vkmegT6GsOL3BLI46kktHgt3iA3C5oKdKwIDAQAB\",\"dmarc\":\"v=DMARC1;p=reject TTL: 1 hour\",\"mx\":[\"mx.runbox.com.\"],\"ns\":[\"dns1.p04.nsone.net.\",\"dns2.p04.nsone.net.\",\"dns3.p04.nsone.net.\",\"dns4.p04.nsone.net.\"],\"spf\":\"v=spf1 include:spf.runbox.com include:spf.mailjet.com +mx ~all\"},\"advice\":{\"bimi\":[\"We couldn't detect any active BIMI record for your domain. Please visit https://dmarcguide.globalcyberalliance.org to fix this.\"],\"dkim\":[\"DKIM is setup for this email server. However, if you have other 3rd party systems, please send a test email to confirm DKIM is setup properly.\"],\"dmarc\":[\"Invalid DMARC policy specified, the record must be p=none/p=quarantine/p=reject.\",\"Consider specifying a 'rua' tag for aggregate reporting.\",\"Consider specifying an 'fo' tag to define the condition for generating failure reports. Default is '0' (report if both SPF and DKIM fail).\",\"Consider specifying a 'ruf' tag for forensic reporting.\",\"Subdomain policy isn't specified, they'll default to the main policy instead.\"],\"domain\":[\"Your domain is using TLS 1.3, no further action needed!\"],\"mx\":[\"You have a single mail server setup, but it's recommended that you have at least two setup in case the first one fails.\",\"mx.runbox.com: Failed to reach domain before timeout\"],\"spf\":[\"SPF seems to be setup correctly! No further action needed.\"]}}\n",
   0}
```

```elixir
parsed_dss_domain_scan =
  dss_domain_scan
  |> Jason.decode!()
```

```elixir
%{
  "advice" => %{
    "bimi" => bimi_advice,
    "dkim" => dkim_advice,
    "dmarc" => dmarc_advice,
    "domain" => domain_advice,
    "mx" => mx_advice,
    "spf" => spf_advice
  },
  "scanResult" => %{
    "dkim" => dkim_scan_result,
    "dmarc" => dmarc_scan_result,
    "spf" => spf_scan_result
  }
} = parsed_dss_domain_scan
```

## Constructing a subdomain tree

To make reading and traversal of our zone easier, a `DnsRecord` structure will store all the relevant information for each record.

```elixir
defmodule DnsRecord do
  defstruct id: "",
            name: "",
            display_name: "",
            type: "",
            weight: 0,
            special_type: "",
            data: "",
            structured_data: %{},
            priority: nil,
            ttl: nil,
            children: [],
            query_tool: "",
            answer_source: ""
end
```

```elixir
defmodule Dns.ZoneTree do
  # To deprecate
  def construct_zone_tree(
        parent_domain,
        dmarc_subdomain_label,
        dkim_subdomain_label,
        known_dkim_selector_list
      ) do
    get_ns_zone_records(parent_domain) ++
      get_mx_zone_records(parent_domain) ++
      get_txt_zone_records(parent_domain) ++
      get_dmarc_record(parent_domain, dmarc_subdomain_label) ++
      get_dkim_records(parent_domain, dkim_subdomain_label, known_dkim_selector_list)
  end

  # To deprecate
  def construct_cname_zone_trees(
        parent_domain,
        subdomain_list,
        dmarc_subdomain_label,
        dkim_subdomain_label,
        known_dkim_selector_list
      ) do
    get_cname_zone_records(
      parent_domain,
      subdomain_list,
      dmarc_subdomain_label,
      dkim_subdomain_label,
      known_dkim_selector_list
    )
  end

  def construct_dns_zone_tree(
        parent_domain,
        subdomain_list,
        dmarc_subdomain_label,
        dkim_subdomain_label,
        known_dkim_selector_list
      ) do
    (get_soa_zone_record(parent_domain) ++
       get_ns_zone_records(parent_domain) ++
       get_a_zone_records(parent_domain) ++
       get_cname_zone_records(
         parent_domain,
         subdomain_list,
         dmarc_subdomain_label,
         dkim_subdomain_label,
         known_dkim_selector_list
       ) ++
       get_mx_zone_records(parent_domain) ++
       get_txt_zone_records(parent_domain) ++
       get_dmarc_record(parent_domain, dmarc_subdomain_label) ++
       get_dkim_records(
         parent_domain,
         dkim_subdomain_label,
         known_dkim_selector_list
       ))
    |> Enum.sort_by(fn rec -> {rec.weight, rec.type, rec.name, rec.data} end)
  end

  def get_soa_zone_record(parent_domain) do
    parent_domain
    |> Dns.Query.get_soa_records()
    |> Dns.Core.handle_record_payload()
  end

  def construct_soa_record(record) do
    Enum.map(record, fn rec ->
      data = Dns.Core.handle_soa_record_data(rec.data)

      construct_dns_record(%{
        id: "SOA",
        display_name: "SOA #{data.mname} zone",
        type: rec.type,
        weight: 0,
        data:
          "Master name: #{data.mname}, Responsible contact: #{data.rname}, Serial number: #{data.serial}, Refresh time: #{data.refresh}, Retry time: #{data.retry}, Expire time: #{data.expire}, Minimum TTL: #{data.minimum}",
        structured_data: data,
        ttl: rec.ttl
      })
    end)
  end

  def get_ns_zone_records(parent_domain) do
    parent_domain
    |> Dns.Query.get_ns_records()
    |> Dns.Core.handle_record_payload()
  end

  def construct_ns_record(record) do
    Enum.map(record, fn rec ->
      construct_dns_record(%{
        id: "ns-#{rec.id}",
        display_name: "NS #{rec.id}",
        type: rec.type,
        weight: 5,
        data: "#{rec.data}",
        ttl: rec.ttl
      })
    end)
  end

  def get_mx_zone_records(parent_domain) do
    parent_domain
    |> Dns.Query.get_mx_records()
    |> Dns.Core.handle_record_payload()
  end

  def construct_mx_record(record) do
    Enum.map(record, fn rec ->
      parsed_data = Dns.Core.handle_mx_record_data(rec.data)

      construct_dns_record(%{
        id: "mx-#{rec.id}",
        display_name: "MX #{rec.id}  #{rec.domain}",
        type: rec.type,
        weight: 10,
        priority: parsed_data.priority,
        data: parsed_data.data,
        ttl: rec.ttl
      })
    end)
  end

  def get_a_zone_records(parent_domain) do
    parent_domain
    |> Dns.Query.get_a_records()
    |> Dns.Core.handle_record_payload()
  end

  def construct_a_record(record) do
    Enum.map(record, fn rec ->
      construct_dns_record(%{
        id: "#{rec.domain}",
        name: "#{rec.domain}",
        display_name: "#{rec.domain}",
        type: rec.type,
        weight: 15,
        data: Dns.Core.handle_record_data(rec.data),
        ttl: rec.ttl
      })
    end)
  end

  def get_cname_zone_records(
        parent_domain,
        subdomain_list,
        dmarc_subdomain_label,
        dkim_subdomain_label,
        known_dkim_selector_list
      )
      when is_list(subdomain_list) do
    subdomain_list
    |> Enum.map(fn %{host: host} = rec ->
      Map.merge(rec, %{
        domain: host,
        host_labels:
          Dns.Core.get_host_name_without_domain(parent_domain, host)
          |> Dns.Core.get_subdomain_labels()
      })
    end)
    |> Enum.map(fn rec ->
      construct_cname_tree(rec, rec.host_labels, [], "", %{
        parent_domain: parent_domain,
        dmarc_subdomain_label: dmarc_subdomain_label,
        dkim_subdomain_label: dkim_subdomain_label,
        known_dkim_selector_list: known_dkim_selector_list
      })
    end)

    # |> Enum.map(fn %{host: host} = rec ->
    #   resolve_for_cname_or_a(host) |> Enum.map(fn irec -> Map.merge(irec, rec) end)
    # end)
    # |> List.flatten()
    # |> Enum.with_index(fn rec, index -> Map.merge(rec, %{id: index + 1}) end)

    # |> Enum.map(fn res ->
    #   construct_cname_record(
    #     res,
    #     host_name: Dns.Core.get_host_name_without_domain(parent_domain, host),
    #     source: source,
    #     tool: tool
    #   )
    # end)
  end

  def construct_cname_tree(_rec, [], [], _acc, _info_map), do: []

  def construct_cname_tree(rec, [head | []], child_records, acc, info_map) do
    host_name = DomainName.join!([head, acc])
    fqdn = DomainName.join!(DomainName.name(host_name), info_map.parent_domain)

    IO.inspect(acc, label: "Acc")
    IO.inspect(host_name, label: "Host")
    IO.inspect(fqdn, label: "FQDN")

    Map.merge(rec, %{
      host_name: host_name,
      fqdn: fqdn,
      children:
        Dns.Query.get_cname_record(fqdn)
        |> Dns.Query.resolves_to_already_seen?([info_map.parent_domain])
        |> case do
          true ->
            []

          false ->
            [
              # Dns.ZoneTree.construct_dns_zone_tree(
              #   host_name,
              #   [],
              #   info_map.dmarc_subdomain_label,
              #   info_map.dkim_subdomain_label,
              #   info_map.known_dkim_selector_list
              # )

              get_soa_zone_record(fqdn),
              get_ns_zone_records(fqdn),
              get_mx_zone_records(fqdn),
              get_a_zone_records(fqdn),
              get_txt_zone_records(fqdn),
              get_dmarc_record(fqdn, info_map.dmarc_subdomain_label),
              get_dkim_records(
                fqdn,
                info_map.dkim_subdomain_label,
                info_map.known_dkim_selector_list
              ),
              [construct_cname_tree(rec, child_records, [], DomainName.name(host_name), info_map)]
            ]
            |> Enum.reject(fn i -> i == [] end)
        end
    })
  end

  def construct_cname_tree(rec, [head | tail], child_records, acc, info_map) do
    construct_cname_tree(rec, [head], tail, acc, info_map)
    # host_name_at_level = DomainName.join!([head, acc])

    # Map.merge(rec, %{
    # host_name: host_name_at_level,
    # children: [construct_cname_tree(rec, tail, host_name_at_level, info_map)]
    # })
  end

  # Deprecated
  def resolve_for_cname_or_a(host) do
    parsed_host = DomainName.new!(host)

    cname_res = Dns.Query.get_record_info(parsed_host, :cname)

    case cname_res do
      [] ->
        a_res = Dns.Query.get_record_info(parsed_host, :a)

        case a_res do
          [] -> nil
          _ -> a_res
        end

      _ ->
        cname_res
    end
  end

  defp construct_cname_record(record, options \\ []) do
    host_name = Keyword.get(options, :host_name, "")
    children = Keyword.get(options, :children, [])

    construct_dns_record(%{
      id: "#{record.domain}",
      name: "#{record.domain}",
      display_name: "#{DomainName.name(host_name)}",
      type: record.type,
      weight: 20,
      data: Dns.Core.handle_record_data(record.data),
      ttl: record.ttl,
      children: children,
      query_tool: record.tool,
      answer_source: record.source
    })
  end

  def resolve_chain(parent_domain, [record | []], child_records) do
    record
  end

  def resolve_chain(parent_domain, [head | tail], child_records),
    do: resolve_chain(parent_domain, [head], tail)

  # Deprecated
  def resolve_cname_chain(parent_domain, record, []) do
    case record.type do
      :cname ->
        construct_cname_record(record,
          host_name: Dns.Core.get_host_name_without_domain(parent_domain, record.domain),
          children: []
        )

      :txt ->
        record
        |> Map.merge(%{id: record.domain, special_type: "DKIM"})
        |> construct_txt_record(id_prefix: "")

      _ ->
        nil
    end
  end

  def resolve_cname_chain(parent_domain, record, next_resolution) do
    [next_hd | next_tl] = next_resolution

    case record.type do
      :cname ->
        construct_cname_record(record,
          host_name: Dns.Core.get_host_name_without_domain(parent_domain, record.domain),
          children: resolve_cname_chain(parent_domain, next_hd, next_tl)
        )

      _ ->
        nil
    end
  end

  def get_txt_zone_records(parent_domain) do
    parent_domain
    |> Dns.Query.get_txt_records()
    |> Dns.Core.handle_record_payload()

    # |> Enum.with_index(fn rec, index ->
    #   Map.merge(rec, %{id: index + 1, special_type: Dns.Core.classify_txt_record_type(rec)})
    # end)
    # |> Enum.map(fn rec -> construct_txt_record(rec) end)
  end

  def get_dmarc_record(parent_domain, subdomain_label) do
    parent_domain
    |> Dns.Query.get_dmarc_record(subdomain_label)
    |> Dns.Core.handle_record_payload()

    # |> Enum.with_index(fn rec, index ->
    #   Map.merge(rec, %{id: index + 1, special_type: "DMARC"})
    # end)
    # |> Enum.map(fn rec ->
    #   construct_txt_record(rec, id_prefix: "dmarc-")
    # end)
  end

  def get_dkim_records(parent_domain, subdomain_label, selector_list) do
    parent_domain
    |> Dns.Query.get_dkim_records(subdomain_label, selector_list)
    |> Dns.Core.handle_record_payload()

    # |> Enum.map(fn
    #   [head | []] ->
    #     head
    #     |> Map.merge(%{id: head.domain, special_type: "DKIM"})
    #     |> construct_txt_record(id_prefix: "")

    #   [head | tail] ->
    #     case head.type do
    #       :cname ->
    #         resolve_cname_chain(parent_domain, head, tail)

    #       _ ->
    #         nil
    #     end

    #   [] ->
    #     []
    # end)
    # |> Enum.filter(fn i -> not is_nil(i) end)
  end

  defp construct_txt_record(record, options \\ []) do
    id_prefix = Keyword.get(options, :id_prefix, "")

    construct_dns_record(%{
      id: "txt-#{id_prefix}#{record.id}",
      name: "#{record.domain}",
      display_name:
        Enum.join(
          [Map.get(record, :special_type, ""), "[TXT]", record.domain],
          " "
        ),
      type: record.type,
      weight: 30,
      special_type: Map.get(record, :special_type, ""),
      data:
        case Map.get(record, :special_type, "") do
          "DKIM" -> Enum.join(record.data)
          _ -> Enum.join(record.data)
        end,
      ttl: record.ttl
    })
  end

  def construct_dns_record(dns_record) when is_map(dns_record) do
    %DnsRecord{
      id: dns_record.id,
      name: Map.get(dns_record, :name, ""),
      display_name: Map.get(dns_record, :display_name, ""),
      type: dns_record.type,
      weight: dns_record.weight,
      data: Map.get(dns_record, :data),
      structured_data: Map.get(dns_record, :structured_data),
      special_type: Map.get(dns_record, :special_type, ""),
      priority: Map.get(dns_record, :priority, nil),
      ttl: dns_record.ttl,
      children: Map.get(dns_record, :children, []),
      query_tool: Map.get(dns_record, :query_tool, ""),
      answer_source: Map.get(dns_record, :answer_source, "")
    }
  end
end
```

```elixir
x_zone_tree =
  Dns.ZoneTree.get_cname_zone_records(
    verified_domain,
    enumerated_subdomains,
    dmarc_subdomain_label,
    dkim_subdomain_label,
    known_dkim_selector_list
  )
```

```elixir
defmodule Q do
  def resolve_chain(
        parent_domain,
        child_domain,
        _subsequent_domain,
        [record | []],
        [next_child | _] = tail
      ) do
    IO.inspect(child_domain, label: "This node")
    IO.inspect(record.data, label: "Record")
    IO.inspect(next_child.domain, label: "Next node")

    cond do
      next_child != [] and DomainName.equal?(child_domain, DomainName.new!(next_child.domain)) ->
        Enum.map([record | tail], fn rec -> rec end)

      true ->
        record
        |> Map.merge(%{
          children:
            cond do
              record.type in [:a, :aaaa, :soa, :txt] ->
                []

              is_list(record.data) and next_child != [] ->
                [
                  resolve_chain(
                    DomainName.new!(record.data),
                    DomainName.new!(next_child.domain),
                    "",
                    tail,
                    []
                  )
                ]

              true ->
                []
            end
        })
    end
  end

  def resolve_chain(
        parent_domain,
        parent_domain,
        _subsequent_domain,
        [head | tail],
        child_records
      ),
      do: resolve_chain(parent_domain, parent_domain, "", [head], tail)
end
```

```elixir
test_tree_segment =
  [node1 | [node2 | [node3 | [node4 | [node5 | _tail]]]]] = x_zone_tree

# test_tree_segment 
# |> Enum.map(fn i -> i.children |> length() end)

node4

fqdn = node4.fqdn

node4.children
|> Enum.map(fn [head | _tail] = ol ->
  ol
  #   Q.resolve_chain(fqdn, DomainName.new!(head.domain), "", ol, [])
end)
```

Reaching in to each map, we can take out the value for each `host` key, returning a simple list of strings.

```elixir
subdomain_list =
  enumerated_subdomains
  |> Enum.map(fn %{host: host} -> host end)
  |> Enum.map(fn host -> DomainName.new!(host) |> Dns.Query.get_soa_records() end)
```

What we've now got is a list of subdomains, with fully-qualified domain names (FQDN). This is very wordy, as each subdomain is fully specified, containing the domain name in full. We don't want that much information, stripping the zone parent domain name from each subdomain, leaving only the actual subdomain name itself.

```elixir
subdomains =
  subdomain_list
  |> Enum.map(fn d ->
    d
    |> DomainName.new!()
    |> DomainName.without_suffix(verified_domain)
    |> case do
      {:ok, s} -> DomainName.name(s)
    end
  end)
  |> Enum.filter(fn i -> i != "" end)
```

```elixir
dns_zone_tree =
  Dns.ZoneTree.construct_dns_zone_tree(
    verified_domain,
    enumerated_subdomains,
    dmarc_subdomain_label,
    dkim_subdomain_label,
    known_dkim_selector_list
  )
```

## DNS record list

```elixir
defmodule DnsZone.RecordList do
  def dns_zone_table_header() do
    """
    | Name |  TTL | Type | Value |
    | :--- | ---: | :--- | :---  | 
    """
  end

  def construct_dns_table_records(dns_zone_tree) do
    dns_zone_tree
    |> Enum.map(fn rec ->
      "| #{rec.name} | #{rec.ttl} | #{String.upcase(Kernel.to_string(rec.type))} | #{rec.data} |"
    end)
    |> Enum.join("\n")
  end

  def construct_dns_zone_table(table_header, tabular_records) do
    table_header <> tabular_records
  end
end
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
Kino.Markdown.new(
  DnsZone.RecordList.construct_dns_zone_table(
    DnsZone.RecordList.dns_zone_table_header(),
    DnsZone.RecordList.construct_dns_table_records(dns_zone_tree)
  )
)
```

## Visualising the DNS zone

With the information now gathered, we can create a usable flowchart diagram, presenting the zone visually. We will use [Mermaid](https://mermaid.js.org/) for this, as it is an easy to use tool for programmatic diagram creation.

<!-- livebook:{"break_markdown":true} -->

To begin with, let's define invariant sections of the diagram definition: initialisation configuration, diagram type and title, and styling. By doing this up front, we're developing the diagram definition in easily managable segments, and defining the diagram in a _literate programming_ style.

```elixir
dns_zone_diagram_configuration =
  """
  %%{ init: { 
    'theme': 'base',
    'themeVariables': {
      'clusterBkg': '#81a1c144;'
    },
    'fontFamily': 'Calluna Sans, Helvetica, Trebuchet MS, Verdana, Arial, Sans-Serif',
    'flowchart': { 
      'curve': 'linear',
      'useMaxWidth': 'true'
     } 
    } }%%
  """
```

```elixir
diagram_type = "flowchart LR"
```

In the following step, we insert the list of edges by order of definition.

```elixir
diagram_styles =
  """
  classDef parent-node fill:turquoise,stroke:#b48ead,stroke-width:1px;
  classDef parent-zone fill:#81a1c144,stroke:#b48ead,stroke-width:1px;
  classDef cname-record fill:#88c0d088,stroke:#b48ead,stroke-width:1px;
  classDef ns-record fill:#bf616a44,stroke:#b48ead,stroke-width:1px;
  classDef mx-record fill:#d0877099,stroke:#b48ead,stroke-width:1px;
  classDef txt-record fill:#ebcb8b88,stroke:#b48ead,stroke-width:1px;
  classDef a-record fill:#a3be8c99,stroke:#b48ead,stroke-width:1px;
  """
```

First, we need a module, `ZoneTree` to convert this data into Mermaid flowchart definition code.

```elixir
defmodule ZoneTree do
  def define_parent_node(parent_domain) do
    strf_format_string = "%Y-%m-%d"

    domain_critical_info = DomainNameQuerying.get_critical_domain_info(parent_domain)
    date_created = domain_critical_info.created_at |> Calendar.strftime(strf_format_string)
    date_updated = domain_critical_info.updated_at |> Calendar.strftime(strf_format_string)
    date_expires = domain_critical_info.expires_at |> Calendar.strftime(strf_format_string)

    "parent-node([\"`#{DomainName.name(parent_domain)}
    —
    Created #{date_created}
    Updated #{date_updated}
    Expiry #{date_expires}`\"]):::parent-node;"
  end

  def define_dns_zone(
        parent_domain,
        dmarc_subdomain_label,
        dkim_subdomain_label,
        known_dkim_selector_list
      ) do
    zone_tree =
      Dns.ZoneTree.construct_zone_tree(
        parent_domain,
        dmarc_subdomain_label,
        dkim_subdomain_label,
        known_dkim_selector_list
      )

    zone_records =
      for rec <- zone_tree do
        construct_zone_records("parent-node", rec)
        #     "parent-node #{define_link_type(rec.type)} #{rec.id}([\"`#{rec.display_name} 
        #     —
        #     TTL #{rec.ttl}
        #     #{if rec.type === :mx, do: rec.priority} #{rec.data}`\"])#{attach_style_class(rec.type)}"
      end

    # zone_records
    # |> Enum.join(";")
  end

  defp construct_zone_records(parent_node, record) do
    "#{parent_node} #{define_link_type(record.type)} #{record.id}([\"`#{record.display_name} 
        —
        TTL #{record.ttl}
        #{if record.type === :mx, do: record.priority} #{if record.special_type == "DKIM", do: String.slice(record.data, 0..25) <> "...", else: record.data}`\"])#{attach_style_class(record.type)};
        #{if Map.get(record, :children, []) != [], do: construct_zone_records(record.id, record.children)}"
  end

  def define_dns_sub_zones(parent_domain, subdomain_list) do
    zone_tree = Dns.ZoneTree.construct_cname_zone_trees(parent_domain, subdomain_list)

    zone_records =
      for rec <- zone_tree do
        "parent-node #{define_link_type(rec.type)} #{rec.id}([\"`#{rec.display_name} #{if rec.type === :mx, do: ": " <> rec.name}
        —
        TTL #{rec.ttl}
        #{if rec.type === :mx, do: rec.priority} #{if rec.special_type == "DKIM", do: String.slice(rec.data, 0..25) <> "...", else: rec.data}`\"])#{attach_style_class(rec.type)}"
      end

    zone_records
    |> Enum.join(";")
  end

  def define_link_type(type) when is_atom(type) do
    case type do
      :a -> "---"
      :ns -> "-.-"
      :mx -> "---"
      :txt -> "---"
      :cname -> "---"
      _ -> "---"
    end
  end

  def attach_style_class(type) when is_atom(type) do
    case type do
      :a -> ":::a-record"
      :ns -> ":::ns-record"
      :mx -> ":::mx-record"
      :txt -> ":::txt-record"
      :cname -> ":::cname-record"
      _ -> ""
    end
  end

  def enumerate_relationships(zone_tree) do
    edges =
      for i <- 0..(length(zone_tree) - 1) do
        "#{i}"
      end

    Enum.join(edges, ",")
  end
end
```

The `construct_tree/1` function takes the parent domain and the list of subdomains, converting them to a node-and-relationship definition string.

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
parent_node = ZoneTree.define_parent_node(verified_domain)

parent_zone =
  ZoneTree.define_dns_zone(
    verified_domain,
    dmarc_subdomain_label,
    dkim_subdomain_label,
    known_dkim_selector_list
  )

# """
# subgraph parent-zone [#{DomainName.name(verified_domain)} zone];

#   direction LR;

# end;
# """

zones =
  ZoneTree.define_dns_sub_zones(verified_domain, enumerated_subdomains)
```

Feeding this definition string into the scaffolded diagram definition provides us with the complete diagram definition.

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
dns_zone_diagram =
  """
  #{dns_zone_diagram_configuration}
  #{diagram_type};

  #{parent_node}

  #{parent_zone}

  #{zones};

  #{diagram_styles}
  """
```

```elixir
Kino.Markdown.new(dns_zone_diagram)
```

The diagram definition, stored in the `dns_zone_diagram` variable, can now be used to draw the DNS zone diagram.

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
Kino.Mermaid.new(dns_zone_diagram)
```

## Audit summary and advice

```elixir
Kino.Markdown.new("""
### BIMI

#{Enum.join(bimi_advice, "\n\n")}


### DKIM

#{Enum.join(dkim_advice, "\n\n")}

**DKIM record** _`#{String.slice(dkim_scan_result, 0..60)}...`_


### DMARC

#{Enum.join(dmarc_advice, "\n\n")}

**DMARC record** _`#{dmarc_scan_result}`_

### Domain

#{Enum.join(domain_advice, "\n\n")}


### MX

#{Enum.join(mx_advice, "\n\n")}


### SPF

#{Enum.join(spf_advice, "\n\n")}

**SPF record** _`#{spf_scan_result}`_
""")
```
