<!-- livebook:{"autosave_interval_s":60} -->

# DNS Zone Explorer

```elixir
Mix.install([
  {:kino, "~> 0.12.3"},
  {:kino_shell, "~> 0.1.2"},
  {:jason, "~> 1.4"},
  {:domainname, "~> 0.1.5"},
  {:whois, "~> 0.2.1"}
])
```

## Domain entry, parsing and querying

To begin, we need user input to know which domain to interrogate, saving the input into the `domain` variable.

```elixir
domain = Kino.Input.text("Enter your domain name")
```

The following will read and attempt to construct a valid domain name and parrot the user input back to us, as a simple form of feedback. If it fails, then an error will warn us of this at this stage.

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
{:ok, verified_domain} =
  DomainName.new(Kino.Input.read(domain),
    must_be_hostname: true
  )
```

```elixir
defmodule DomainNameQuerying do
  def domain_name_query(domain_name) do
    domain_name
    |> DomainName.name()
    |> Whois.lookup()
  end

  def get_critical_domain_info(domain_name) do
    case domain_name_query(domain_name) do
      {:ok,
       %Whois.Record{
         registrar: registrar,
         created_at: created_at,
         updated_at: updated_at,
         expires_at: expires_at
       }} ->
        %{
          registrar: registrar,
          created_at: created_at,
          updated_at: updated_at,
          expires_at: expires_at
        }

      {_, _} ->
        {:error}
    end
  end
end
```

## Using Erlang's :inet_res builtin functionality

```elixir
defmodule DomainRecordQuerying do
  def get_record_info(dns_name, type) when is_atom(type) do
    dns_name
    |> DomainName.name()
    |> String.to_charlist()
    |> :inet_res.resolve(:in, type)
    |> case do
      {:ok, res} ->
        res
        |> :inet_dns.msg()
        |> Keyword.fetch!(:anlist)
        |> Enum.map(fn i -> :inet_dns.rr(i) end)

      {:error, reason} ->
        {:error, reason}
    end
  end

  def get_ns_records(parent_domain) do
    get_record_info(parent_domain, :ns)
  end

  def get_mx_records(parent_domain) do
    get_record_info(parent_domain, :mx)
  end

  def get_txt_records(parent_domain) do
    get_record_info(parent_domain, :txt)
  end
end
```

## On DNS zone enumeration

For security reasons, it is difficult to get a true state of a DNS zone, as this is information which would be used by attackers in finding exploits.

To enumerate subdomains of a domain, we will turn to several penetration testing tools.

<!-- livebook:{"break_markdown":true} -->

Let's get locations of all subdomain enumeration tools we may need, into variables we can use.

```elixir
amass_binary = System.get_env("LB_AMASS_BIN")
assetfinder_binary = System.get_env("LB_ASSETFINDER_BIN")
dnsrecon_binary = System.get_env("LB_DNSRECON_BIN")
puredns_binary = System.get_env("LB_PUREDNS_BIN")
subfinder_binary = System.get_env("LB_SUBFINDER_BIN")
sublist3r_binary = System.get_env("LB_SUBLIST3R_BIN")
:ok
```

## Subdomain enumeration

We now call out to `System.cmd` to run `subfinder` on our domain. Note that ease of parsing is most important here, thus the tool is run with a few additional options:

* `-silent` so that the masthead message, progress and other messages are not printed to `stdout`
* `-json` to return a list of JSON-formatted results, for each enumerated subdomain
* `-active` to display active subdomains only

**PLEASE NOTE** This command is run on the network, querying multiple internet sources, and as such is likely to take some time, typically needing 30 seconds or more. Please be patient and don't interrupt it unnecessarily. For additional informative use, `stderr` has been redirected to `stdout` to show error messages, if any.

```elixir
{subfinder_query_result, 0} =
  System.cmd(
    "bash",
    ["-lc", "#{subfinder_binary} -d #{DomainName.name(verified_domain)} -silent -json -active"],
    stderr_to_stdout: true
  )
```

With query results saved to `subfinder_query_results`, we now need to clean up the results by splitting away newline characters (`\n`), filtering out empty strings, and parsing the JSON results.

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
enumerated_subdomains =
  subfinder_query_result
  |> String.split("\n")
  |> Enum.filter(fn rec -> rec != "" end)
  |> Enum.map(fn rec -> Jason.decode!(rec) end)
  |> Enum.filter(fn %{"host" => host} -> host != DomainName.name(verified_domain) end)
```

## Creating a subdomain tree

To make reading and traversal of our zone easier, a `DnsRecord` structure will store all the relevant information for each record.

```elixir
defmodule DnsRecord do
  defstruct id: "",
            name: "",
            display_name: "",
            type: "",
            data: "",
            priority: nil,
            ttl: nil,
            children: [],
            query_tool: "",
            answer_source: ""
end
```

```elixir
defmodule DnsZoneTree do
  def construct_zone_tree(parent_domain, subdomain_list) do
    get_ns_zone_records(parent_domain) ++
      get_mx_zone_records(parent_domain) ++
      get_txt_zone_records(parent_domain)
  end

  def construct_cname_zone_trees(parent_domain, subdomain_list) do
    get_cname_zone_records(parent_domain, subdomain_list)
  end

  def get_ns_zone_records(parent_domain) do
    parent_domain
    |> DomainRecordQuerying.get_ns_records()
    |> Enum.map(fn rec -> Enum.into(rec, %{}) end)
    |> Enum.with_index(fn rec, index -> Map.merge(rec, %{id: index + 1}) end)
    |> Enum.map(fn rec -> construct_ns_dns_record(parent_domain, rec) end)
  end

  def get_mx_zone_records(parent_domain) do
    parent_domain
    |> DomainRecordQuerying.get_mx_records()
    |> Enum.map(fn rec -> Enum.into(rec, %{}) end)
    |> Enum.with_index(fn rec, index -> Map.merge(rec, %{id: index + 1}) end)
    |> Enum.map(fn rec -> construct_mx_dns_record(parent_domain, rec) end)
  end

  def get_txt_zone_records(parent_domain) do
    parent_domain
    |> DomainRecordQuerying.get_txt_records()
    |> Enum.map(fn rec -> construct_dns_record(parent_domain, rec) end)
  end

  def get_cname_zone_records(parent_domain, subdomain_list) when is_list(subdomain_list) do
    subdomain_list
    |> Enum.map(fn rec -> construct_cname_dns_record(parent_domain, rec) end)
    |> Enum.filter(fn rec -> not is_nil(rec) end)
  end

  def construct_dns_record(parent_domain, inet_dns_rr_record) do
    %DnsRecord{
      id: Kernel.to_string(inet_dns_rr_record[:domain]),
      name: Kernel.to_string(inet_dns_rr_record[:domain]),
      display_name: Kernel.to_string(inet_dns_rr_record[:domain]),
      type: inet_dns_rr_record[:type],
      data: Kernel.to_string(inet_dns_rr_record[:data]),
      ttl: inet_dns_rr_record[:ttl]
    }
  end

  def construct_ns_dns_record(_parent_domain, inet_dns_rr_record) do
    %DnsRecord{
      id: "ns-#{inet_dns_rr_record.id}",
      name: Kernel.to_string(inet_dns_rr_record[:domain]),
      display_name: "NS #{inet_dns_rr_record.id}",
      type: inet_dns_rr_record[:type],
      data: Kernel.to_string(inet_dns_rr_record[:data]),
      ttl: inet_dns_rr_record[:ttl]
    }
  end

  def construct_mx_dns_record(_parent_domain, inet_dns_rr_record) do
    {priority, data} = inet_dns_rr_record.data

    %DnsRecord{
      id: "mx-#{inet_dns_rr_record.id}",
      name: Kernel.to_string(inet_dns_rr_record[:domain]),
      display_name: "MX #{inet_dns_rr_record.id}",
      type: inet_dns_rr_record[:type],
      priority: priority,
      data: data,
      ttl: inet_dns_rr_record[:ttl]
    }
  end

  def construct_cname_dns_record(
        parent_domain,
        %{"host" => host, "source" => source} = _cname_record
      ) do
    inet_dns_rr_record =
      DomainName.new!(host)
      |> DomainRecordQuerying.get_record_info(:cname)

    cond do
      length(inet_dns_rr_record) > 0 ->
        record = hd(inet_dns_rr_record)

        {:ok, display_name} =
          DomainName.without_suffix(
            DomainName.new!(Kernel.to_string(record[:domain])),
            parent_domain
          )

        %DnsRecord{
          id: Kernel.to_string(record[:domain]),
          name: Kernel.to_string(record[:domain]),
          display_name: DomainName.name(display_name),
          type: :cname,
          data: Kernel.to_string(record[:data]),
          ttl: record[:ttl],
          query_tool: "subfinder",
          answer_source: source
        }

      true ->
        nil
    end
  end
end
```

Reaching in to each map, we can take out the value for each `host` key, returning a simple list of strings.

```elixir
subdomain_list =
  enumerated_subdomains
  |> Enum.map(fn %{"host" => host} -> host end)
```

What we've now got is a list of subdomains, with fully-qualified domain names (FQDN). This is very wordy, as each subdomain is fully specified, containing the domain name in full. We don't want that much information, stripping the zone parent domain name from each subdomain, leaving only the actual subdomain name itself.

```elixir
subdomains =
  subdomain_list
  |> Enum.map(fn d ->
    d
    |> DomainName.new!()
    |> DomainName.without_suffix(verified_domain)
    |> case do
      {:ok, s} -> DomainName.name(s)
    end
  end)
  |> Enum.filter(fn i -> i != "" end)
```

As it will be necessary later, in the diagram generation and styling stage, let's calculate how many nodes we need to diagram, saving it into the `nmber_of_relationships` variable.

## Visualising the DNS zone

With the information now gathered, we can create a usable flowchart diagram, presenting the zone visually. We will use [Mermaid](https://mermaid.js.org/) for this, as it is an easy to use tool for programmatic diagram creation.

<!-- livebook:{"break_markdown":true} -->

To begin with, let's define invariant sections of the diagram definition: initialisation configuration, diagram type and title, and styling. By doing this up front, we're developing the diagram definition in easily managable segments, and defining the diagram in a _literate programming_ style.

```elixir
dns_zone_diagram_configuration =
  """
  %%{ init: { 
    'theme': 'base',
    'themeVariables': {
      'clusterBkg': '#81a1c144;'
    },
    'fontFamily': 'Calluna Sans, Helvetica, Trebuchet MS, Verdana, Arial, Sans-Serif',
    'flowchart': { 
      'curve': 'linear',
      'useMaxWidth': 'true'
     } 
    } }%%
  """
```

```elixir
diagram_type = "flowchart LR"
```

In the following step, we insert the list of edges by order of definition.

```elixir
diagram_styles =
  """
  classDef parent-node fill:turquoise;
  classDef parent-zone fill:#81a1c144;
  classDef cname-record fill:#88c0d088;
  classDef ns-record fill:#bf616a44;
  classDef mx-record fill:#d0877099;
  classDef txt-record fill:#ebcb8b88;
  classDef a-record color:#222;
  """
```

First, we need a module, `ZoneTree` to convert this data into Mermaid flowchart definition code.

```elixir
defmodule ZoneTree do
  def define_parent_node(parent_domain) do
    strf_format_string = "%Y-%m-%d"

    domain_critical_info = DomainNameQuerying.get_critical_domain_info(parent_domain)
    date_created = domain_critical_info.created_at |> Calendar.strftime(strf_format_string)
    date_updated = domain_critical_info.updated_at |> Calendar.strftime(strf_format_string)
    date_expires = domain_critical_info.expires_at |> Calendar.strftime(strf_format_string)

    "parent-node([\"`#{DomainName.name(parent_domain)}
    —
    Created #{date_created}
    Updated #{date_updated}
    Expiry #{date_expires}`\"]):::parent-node;"
  end

  def define_dns_zone(parent_domain, subdomain_list) do
    zone_tree = DnsZoneTree.construct_zone_tree(parent_domain, subdomain_list)

    zone_records =
      for rec <- zone_tree do
        "parent-node #{define_link_type(rec.type)} #{rec.id}([\"`#{if rec.type === :txt, do: "TXT: "}#{rec.display_name} #{if rec.type === :mx, do: ": " <> rec.name}
        —
        TTL #{rec.ttl}
        #{if rec.type === :mx, do: rec.priority} #{rec.data}`\"])#{attach_style_class(rec.type)}"
      end

    zone_records
    |> Enum.join(";")
  end

  def define_dns_sub_zones(parent_domain, subdomain_list) do
    zone_tree = DnsZoneTree.construct_cname_zone_trees(parent_domain, subdomain_list)

    zone_records =
      for rec <- zone_tree do
        "parent-node #{define_link_type(rec.type)} #{rec.id}([\"`#{if rec.type === :txt, do: "TXT: "}#{rec.display_name} #{if rec.type === :mx, do: ": " <> rec.name}
        —
        TTL #{rec.ttl}
        #{if rec.type === :mx, do: rec.priority} #{rec.data}`\"])#{attach_style_class(rec.type)}"
      end

    zone_records
    |> Enum.join(";")
  end

  def define_link_type(type) when is_atom(type) do
    case type do
      :a -> "---"
      :ns -> "-.-"
      :mx -> "---"
      :txt -> "---"
      :cname -> "-----"
      _ -> "---"
    end
  end

  def attach_style_class(type) when is_atom(type) do
    case type do
      :a -> ":::a-record"
      :ns -> ":::ns-record"
      :mx -> ":::mx-record"
      :txt -> ":::txt-record"
      :cname -> ":::cname-record"
      _ -> ""
    end
  end

  def enumerate_relationships(zone_tree) do
    edges =
      for i <- 0..(length(zone_tree) - 1) do
        "#{i}"
      end

    Enum.join(edges, ",")
  end
end
```

The `construct_tree/1` function takes the parent domain and the list of subdomains, converting them to a node-and-relationship definition string.

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
parent_node = ZoneTree.define_parent_node(verified_domain)

parent_zone =
  """
  subgraph parent-zone [#{DomainName.name(verified_domain)} zone];
    direction LR;
    #{ZoneTree.define_dns_zone(verified_domain, enumerated_subdomains)};
  end;
  """

zones =
  ZoneTree.define_dns_sub_zones(verified_domain, enumerated_subdomains)
```

Feeding this definition string into the scaffolded diagram definition provides us with the complete diagram definition.

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
dns_zone_diagram =
  """
  #{dns_zone_diagram_configuration}
  #{diagram_type};
  #{parent_node}
  #{parent_zone}
  #{zones}
  #{diagram_styles}
  """
```

The diagram definition, stored in the `dns_zone_diagram` variable, can now be used to draw the DNS zone diagram.

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
Kino.Mermaid.new(dns_zone_diagram)
```
