<!-- livebook:{"autosave_interval_s":60} -->

# DNS Zone Explorer

```elixir
Mix.install([
  {:kino, "~> 0.12.3"},
  {:kino_shell, "~> 0.1.2"},
  {:jason, "~> 1.4"},
  {:domainname, "~> 0.1.5"},
  {:whois, "~> 0.2.1"}
])
```

## Domain entry, parsing and querying

To begin, we need user input to know which domain to interrogate, saving the input into the `domain` variable.

```elixir
domain = Kino.Input.text("Enter your domain name")
```

The following will read and attempt to construct a valid domain name and parrot the user input back to us, as a simple form of feedback. If it fails, then an error will warn us of this at this stage.

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
{:ok, verified_domain} =
  DomainName.new(Kino.Input.read(domain),
    must_be_hostname: true
  )
```

```elixir
defmodule DomainNameQuerying do
  def domain_name_query(domain_name) do
    domain_name
    |> DomainName.name()
    |> Whois.lookup()
  end

  def get_critical_domain_info(domain_name) do
    case domain_name_query(domain_name) do
      {:ok,
       %Whois.Record{
         registrar: registrar,
         created_at: created_at,
         updated_at: updated_at,
         expires_at: expires_at
       }} ->
        %{
          registrar: registrar,
          created_at: created_at,
          updated_at: updated_at,
          expires_at: expires_at
        }

      {_, _} ->
        {:error}
    end
  end
end
```

## Using Erlang's :inet_res builtin functionality

```elixir
# res = 
#   verified_domain
#   |> DomainName.name()
# |> :inet_res.resolve('magicpillsmovie.com', :in, :txt)

# res
# |> :inet_dns.msg()
# |> Keyword.fetch!(:anlist)
# |> Enum.map(fn n -> :inet_dns.rr(n) end)

# IEx.Helpers.i("test")
# "test"
# |> Kernel.to_charlist()
# |> IEx.Helpers.i
```

## On DNS zone enumeration

For security reasons, it is difficult to get a true state of a DNS zone, as this is information which would be used by attackers in finding exploits.

To enumerate subdomains of a domain, we will turn to several penetration testing tools.

<!-- livebook:{"break_markdown":true} -->

Let's get locations of all subdomain enumeration tools we may need, into variables we can use.

```elixir
amass_binary = System.get_env("LB_AMASS_BIN")
assetfinder_binary = System.get_env("LB_ASSETFINDER_BIN")
dnsrecon_binary = System.get_env("LB_DNSRECON_BIN")
puredns_binary = System.get_env("LB_PUREDNS_BIN")
subfinder_binary = System.get_env("LB_SUBFINDER_BIN")
sublist3r_binary = System.get_env("LB_SUBLIST3R_BIN")
:ok
```

## Subdomain enumeration

We now call out to `System.cmd` to run `subfinder` on our domain. Note that ease of parsing is most important here, thus the tool is run with a few additional options:

* `-silent` so that the masthead message, progress and other messages are not printed to `stdout`
* `-json` to return a list of JSON-formatted results, for each enumerated subdomain
* `-active` to display active subdomains only

**PLEASE NOTE** This command is run on the network, querying multiple internet sources, and as such is likely to take some time, typically needing 30 seconds or more. Please be patient and don't interrupt it unnecessarily. For additional informative use, `stderr` has been redirected to `stdout` to show error messages, if any.

```elixir
{subfinder_query_result, 0} =
  System.cmd(
    "bash",
    ["-lc", "#{subfinder_binary} -d #{DomainName.name(verified_domain)} -silent -json -active"],
    stderr_to_stdout: true
  )
```

With query results saved to `subfinder_query_results`, we now need to clean up the results by splitting away newline characters (`\n`), filtering out empty strings, and parsing the JSON results.

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
enumerated_subdomains =
  subfinder_query_result
  |> String.split("\n")
  |> Enum.filter(fn i -> i != "" end)
  |> Enum.map(fn i -> Jason.decode!(i) end)
```

## Creating a subdomain tree

To make reading and traversal of our zone easier, a `DnsRecord` structure will store all the relevant information for each record.

```elixir
defmodule DnsRecord do
  defstruct name: "",
            type: "",
            value: "",
            ttl: nil,
            children: [],
            query_tool: "",
            answer_source: ""
end
```

```elixir
enumerated_subdomains
|> Enum.map(fn %{"host" => host, "source" => source} ->
  %DnsRecord{
    name: host,
    type: "CNAME",
    query_tool: "subfinder",
    answer_source: source
  }
end)
```

Reaching in to each map, we can take out the value for each `host` key, returning a simple list of strings.

```elixir
subdomain_list =
  enumerated_subdomains
  |> Enum.map(fn %{"host" => host} -> host end)
```

What we've now got is a list of subdomains, with fully-qualified domain names (FQDN). This is very wordy, as each subdomain is fully specified, containing the domain name in full. We don't want that much information, stripping the zone parent domain name from each subdomain, leaving only the actual subdomain name itself.

```elixir
subdomains =
  subdomain_list
  |> Enum.map(fn d ->
    d
    |> DomainName.new!()
    |> DomainName.without_suffix(verified_domain)
    |> case do
      {:ok, s} -> DomainName.name(s)
    end
  end)
  |> Enum.filter(fn i -> i != "" end)
```

As it will be necessary later, in the diagram generation and styling stage, let's calculate how many nodes we need to diagram, saving it into the `nmber_of_relationships` variable.

```elixir
number_of_relationships = length(subdomains)
```

## Visualising the DNS zone

With the information now gathered, we can create a usable flowchart diagram, presenting the zone visually. We will use [Mermaid](https://mermaid.js.org/) for this, as it is an easy to use tool for programmatic diagram creation.

<!-- livebook:{"break_markdown":true} -->

To begin with, let's define invariant sections of the diagram definition: initialisation configuration, diagram type and title, and styling. By doing this up front, we're developing the diagram definition in easily managable segments, and defining the diagram in a _literate programming_ style.

```elixir
dns_zone_diagram_configuration =
  """
  %%{ init: { 
    'fontFamily': 'Calluna Sans, Helvetica, Trebuchet MS, Verdana, Arial, Sans-Serif',
    'flowchart': { 
      'curve': 'linear',
      'useMaxWidth': 'true'
     } 
    } }%%
  """
```

```elixir
diagram_type = "flowchart TD"
```

As Mermaid doesn't define unique IDs for edges (node connections), it instead affords styling links by the order number in which they were defined. Instead of overriding the style globally, we need to specify the link order. We'll use a simple generator to produce this list of edges, which we will dynamically insert into the styling definition.

```elixir
edges =
  for i <- 0..(number_of_relationships - 1) do
    "#{i}"
  end

full_edge_listing = Enum.join(edges, ",")
```

In the following step, we insert the list of edges by order of definition.

```elixir
diagram_styles =
  """
  linkStyle #{full_edge_listing} stroke:#000,stroke-width:1px,color:#000
  classDef parent-node fill:turquoise;
  classDef subdomain color:#222;
  """
```

First, we need a module, `ZoneTree` to convert this data into Mermaid flowchart definition code.

```elixir
defmodule ZoneTree do
  def construct_tree(subdomain_list) when is_list(subdomain_list) do
    for s <- subdomain_list, into: [] do
      "parent-node --- #{s}([#{s}]):::subdomain"
    end
  end

  def define_parent_node(parent_domain) do
    strf_format_string = "%Y-%m-%d"

    domain_critical_info = DomainNameQuerying.get_critical_domain_info(parent_domain)
    date_created = domain_critical_info.created_at |> Calendar.strftime(strf_format_string)
    date_updated = domain_critical_info.updated_at |> Calendar.strftime(strf_format_string)
    date_expires = domain_critical_info.expires_at |> Calendar.strftime(strf_format_string)

    "parent-node([\"`#{DomainName.name(parent_domain)}
    â€”
    Created #{date_created}
    Updated #{date_updated}
    Expiry #{date_expires}`\"]):::parent-node;"
  end
end
```

The `construct_tree/1` function takes the parent domain and the list of subdomains, converting them to a node-and-relationship definition string.

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
parent_node = ZoneTree.define_parent_node(verified_domain)

nodes =
  ZoneTree.construct_tree(subdomains) |> Enum.join(";")
```

Feeding this definition string into the scaffolded diagram definition provides us with the complete diagram definition.

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
dns_zone_diagram =
  """
  #{dns_zone_diagram_configuration}
  #{diagram_type};
  #{parent_node}
  #{nodes}
  #{diagram_styles}
  """
```

The diagram definition, stored in the `dns_zone_diagram` variable, can now be used to draw the DNS zone diagram.

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
Kino.Mermaid.new(dns_zone_diagram)
```
