<!-- livebook:{"autosave_interval_s":60} -->

# DNS Zone Explorer

```elixir
Mix.install([
  {:kino, "~> 0.12.3"},
  {:kino_shell, "~> 0.1.2"},
  {:jason, "~> 1.4"},
  {:domainname, "~> 0.1.5"},
  {:whois, "~> 0.2.1"}
])
```

## Domain entry, parsing and querying

To begin, we need user input to know which domain to interrogate, saving the input into the `domain` variable.

```elixir
domain = Kino.Input.text("Enter your domain name")
```

The following will read and attempt to construct a valid domain name and parrot the user input back to us, as a simple form of feedback. If it fails, then an error will warn us of this at this stage.

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
{:ok, verified_domain} =
  DomainName.new(Kino.Input.read(domain),
    must_be_hostname: true
  )
```

```elixir
defmodule DomainNameQuerying do
  def domain_name_query(domain_name) do
    domain_name
    |> DomainName.name()
    |> Whois.lookup()
  end

  def get_critical_domain_info(domain_name) do
    case domain_name_query(domain_name) do
      {:ok,
       %Whois.Record{
         registrar: registrar,
         created_at: created_at,
         updated_at: updated_at,
         expires_at: expires_at
       }} ->
        %{
          registrar: registrar,
          created_at: created_at,
          updated_at: updated_at,
          expires_at: expires_at
        }

      {_, _} ->
        {:error}
    end
  end
end
```

## Defining special variables

Email authentication is a collection of techniques aimed at providing verifiable information about the origin of email messages. Three authentication methods have been widely adopted: DKIM, SPF and DMARC. DKIM and DMARC are specified as DNS records, using specific _subdomain labels_, which we define in this section.

BIMI is a branding specification, and as it is bound to be more widely used, we will specify its own subdomain label requirement as well.

```elixir
dkim_subdomain_label = "_domainkey"
dmarc_subdomain_label = "_dmarc"
bimi_subdomain_label = "_bimi"
```

Let's define a set of DKIM selectors in `dkim_selector_list`, as a valid selector is needed to query for a DKIM key.

```elixir
known_dkim_selector_list = [
  # Generic
  "x",
  # Google
  "google",
  # Microsoft
  "selector1",
  # Microsoft
  "selector2",
  # MailChimp
  "k1",
  # Mandrill
  "mandrill",
  # Everlytic
  "everlytickey1",
  # Everlytic
  "everlytickey2",
  # Hetzner
  "dkim",
  # MxVault 
  "mxvault",
  # MailJet
  "mailjet",
  # Avoccado.ai
  "pic"
]
```

Let's get locations of all subdomain enumeration tools we may need, into variables we can use.

```elixir
amass_binary = System.get_env("LB_AMASS_BIN")
assetfinder_binary = System.get_env("LB_ASSETFINDER_BIN")
dnsrecon_binary = System.get_env("LB_DNSRECON_BIN")
puredns_binary = System.get_env("LB_PUREDNS_BIN")
subfinder_binary = System.get_env("LB_SUBFINDER_BIN")
sublist3r_binary = System.get_env("LB_SUBLIST3R_BIN")
dss_binary = System.get_env("LB_DSS_BIN")
:ok
```

## Using Erlang's :inet_res builtin functionality

```elixir
defmodule DomainRecordQuerying do
  def get_record_info(dns_name, type) when is_atom(type) do
    dns_name
    |> DomainName.name()
    |> String.to_charlist()
    |> :inet_res.resolve(:in, type)
    |> case do
      {:ok, res} ->
        res
        |> :inet_dns.msg()
        |> Keyword.fetch!(:anlist)
        |> Enum.map(fn i -> Enum.into(:inet_dns.rr(i), %{}) end)

      {:error, reason} ->
        {:error, reason}
    end
  end

  def get_ns_records(parent_domain) do
    get_record_info(parent_domain, :ns)
  end

  def get_mx_records(parent_domain) do
    get_record_info(parent_domain, :mx)
  end

  def get_txt_records(parent_domain) do
    get_record_info(parent_domain, :txt)
  end

  def get_dmarc_record(parent_domain, dmarc_subdomain_label) do
    construct_subdomain_host(parent_domain, dmarc_subdomain_label)
    |> get_record_info(:txt)
  end

  def construct_subdomain_host(parent_domain, subdomain_label) do
    DomainName.join!(subdomain_label, parent_domain)
  end

  def get_dkim_record(parent_domain, dkim_subdomain_label, selector_list)
      when is_list(selector_list) do
    dkim_subdomain = construct_subdomain_host(parent_domain, dkim_subdomain_label)

    Enum.map(selector_list, fn sel ->
      get_record_info(
        construct_subdomain_host(dkim_subdomain, sel),
        :txt
      )
    end)
    |> Enum.filter(fn
      {:error, _} -> false
      _ -> true
    end)
  end
end
```

```elixir
DomainRecordQuerying.get_dkim_record(
  verified_domain,
  dkim_subdomain_label,
  known_dkim_selector_list
)
```

As any record query may return a `CNAME`—or a _canonical name_—response, which the client will immediately query all the way until it encounters a non-CNAME response, we will receive a response list. This possibility needs to be checked, as it means getting multiple answer records, and this needs to be handled appropriately.

Two ways present themselves, the quick one being to discard all but the last record in the list, as this is likely to be the final one, and the one we actually want. Doing this, however, means eliding potentially useful information, at least for debugging, as it would not be clear how we came to the final record, without seeing the alias traversals within. In cases of DNS cache poisoning, or even Man-in-the-Middle (MITM) attacks, discovering unexpected `CNAME` records is critical in helping spot vulnerabilities, so they should be kept and reported on for a full picture of the state of the zone. Showing the full redirection picture aids in upholding the _principle of least astonishment_, in that it shouldn't cause surprise or consternation to systems administrators, or those developers who are not aware of every infrastructure decision taken to date.

## On DNS zone enumeration

For security reasons, it is difficult to get a true state of a DNS zone, as this is information which would be used by attackers in finding exploits.

To enumerate subdomains of a domain, we will turn to several penetration testing tools.

## Subdomain enumeration

We now call out to `System.cmd` to run `subfinder` on our domain. Note that ease of parsing is most important here, thus the tool is run with a few additional options:

* `-silent` so that the masthead message, progress and other messages are not printed to `stdout`
* `-json` to return a list of JSON-formatted results, for each enumerated subdomain
* `-active` to display active subdomains only

**PLEASE NOTE** This command is run on the network, querying multiple internet sources, and as such is likely to take some time, typically needing 30 seconds or more. Please be patient and don't interrupt it unnecessarily. For additional informative use, `stderr` has been redirected to `stdout` to show error messages, if any.

```elixir
{subfinder_query_result, 0} =
  System.cmd(
    "bash",
    ["-lc", "#{subfinder_binary} -d #{DomainName.name(verified_domain)} -silent -json -active"],
    stderr_to_stdout: true
  )
```

With query results saved to `subfinder_query_results`, we now need to clean up the results by splitting away newline characters (`\n`), filtering out empty strings, and parsing the JSON results.

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
enumerated_subdomains =
  subfinder_query_result
  |> String.split("\n")
  |> Enum.filter(fn rec -> rec != "" end)
  |> Enum.map(fn rec -> Jason.decode!(rec) end)
  |> Enum.map(fn m ->
    m
    |> Map.new(fn {k, v} -> {String.to_atom(k), v} end)
    |> Map.merge(%{tool: "subfinder"})
  end)
  |> Enum.filter(fn %{host: host} -> host != DomainName.name(verified_domain) end)
```

## Get DKIM, DMARC and SPF records

```elixir
{dss_domain_scan, 0} =
  System.cmd(
    "bash",
    [
      "-lc",
      "#{dss_binary} scan #{DomainName.name(verified_domain)} --advise --checkTls --format json"
    ],
    stderr_to_stdout: true
  )
```

```elixir
parsed_dss_domain_scan =
  dss_domain_scan
  |> Jason.decode!()
```

```elixir
%{
  "advice" => %{
    "bimi" => bimi_advice,
    "dkim" => dkim_advice,
    "dmarc" => dmarc_advice,
    "domain" => domain_advice,
    "mx" => mx_advice,
    "spf" => spf_advice
  },
  "scanResult" => %{
    "dkim" => dkim_scan_result,
    "dmarc" => dmarc_scan_result,
    "spf" => spf_scan_result
  }
} = parsed_dss_domain_scan
```

## Creating a subdomain tree

To make reading and traversal of our zone easier, a `DnsRecord` structure will store all the relevant information for each record.

```elixir
defmodule DnsRecord do
  defstruct id: "",
            name: "",
            display_name: "",
            type: "",
            special_type: "",
            data: "",
            priority: nil,
            ttl: nil,
            children: [],
            query_tool: "",
            answer_source: ""
end
```

```elixir
defmodule DnsZoneTree do
  def construct_zone_tree(parent_domain, dmarc_subdomain_label) do
    get_ns_zone_records(parent_domain) ++
      get_mx_zone_records(parent_domain) ++
      get_txt_zone_records(parent_domain) ++
      get_dmarc_record(parent_domain, dmarc_subdomain_label)
  end

  def construct_cname_zone_trees(parent_domain, subdomain_list) do
    get_cname_zone_records(parent_domain, subdomain_list)
  end

  def get_ns_zone_records(parent_domain) do
    parent_domain
    |> DomainRecordQuerying.get_ns_records()
    |> Enum.with_index(fn rec, index -> Map.merge(rec, %{id: index + 1}) end)
    |> Enum.map(fn rec ->
      construct_dns_record(%{
        id: "ns-#{rec.id}",
        name: "#{rec.domain}",
        display_name: "NS #{rec.id}",
        type: rec.type,
        special_type: nil,
        data: "#{rec.data}",
        ttl: rec.ttl,
        children: []
      })
    end)
  end

  def get_mx_zone_records(parent_domain) do
    parent_domain
    |> DomainRecordQuerying.get_mx_records()
    |> Enum.with_index(fn rec, index -> Map.merge(rec, %{id: index + 1}) end)
    |> Enum.map(fn rec ->
      construct_dns_record(%{
        id: "mx-#{rec.id}",
        name: "#{rec.domain}",
        display_name: "MX #{rec.id}  #{rec.domain}",
        type: rec.type,
        special_type: nil,
        priority: get_mx_record_priority_and_data(rec.data).priority,
        data: Kernel.to_string(get_mx_record_priority_and_data(rec.data).data),
        ttl: rec.ttl,
        children: []
      })
    end)
  end

  def get_txt_zone_records(parent_domain) do
    parent_domain
    |> DomainRecordQuerying.get_txt_records()
    |> Enum.with_index(fn rec, index -> Map.merge(rec, %{id: index + 1}) end)
    |> Enum.map(fn rec -> construct_txt_record(rec) end)
  end

  def get_dmarc_record(parent_domain, subdomain_label) do
    parent_domain
    |> DomainRecordQuerying.get_dmarc_record(subdomain_label)
    |> Enum.with_index(fn rec, index -> Map.merge(rec, %{id: index + 1}) end)
    |> Enum.map(fn rec ->
      construct_txt_record(rec, id_prefix: "dmarc-", special_type: "DMARC")
    end)
  end

  def get_dkim_records(parent_domain, subdomain_label, selector_list) do
    parent_domain
    |> DomainRecordQuerying.get_dkim_record(subdomain_label, selector_list)
    |> Enum.map(fn
      [head | []] ->
        head
        |> Map.merge(%{id: head.domain})
        |> construct_txt_record(id_prefix: "", special_type: "DKIM")

      [head | tail] ->
        # case head.type do
        #   :cname -> construct_cname_dns_record(parent_domain, tail, head)
        #   _ -> nil
        # end
        nil
    end)
    |> Enum.filter(fn i -> not is_nil(i) end)
  end

  defp construct_txt_record(record, options \\ []) do
    id_prefix = Keyword.get(options, :id_prefix, "")
    special_type = Keyword.get(options, :special_type, classify_txt_record_type(record))

    construct_dns_record(%{
      id: "txt-#{id_prefix}#{record.id}",
      name: "#{record.domain}",
      display_name: Enum.join([special_type, "[TXT]", record.domain], " "),
      type: record.type,
      special_type: special_type,
      data: Enum.join(record.data),
      ttl: record.ttl,
      children: []
    })
  end

  def classify_txt_record_type(record) do
    data_string = Enum.join(record.data)
    spf_re = ~r/^v=spf1.*/

    cond do
      String.match?(data_string, spf_re) -> "SPF"
      true -> ""
    end
  end

  def get_mx_record_priority_and_data(record) do
    {priority, data} = record

    %{priority: priority, data: data}
  end

  def get_cname_zone_records(parent_domain, subdomain_list) when is_list(subdomain_list) do
    subdomain_list
    |> Enum.map(fn rec -> construct_cname_dns_record(parent_domain, [], rec) end)
    |> List.flatten()
    |> Enum.filter(fn rec -> not is_nil(rec) end)
    |> Enum.with_index(fn rec, index -> Map.merge(rec, %{id: index + 1}) end)
  end

  def resolve_for_cname_or_a(host) do
    parsed_host = DomainName.new!(host)

    cname_res = DomainRecordQuerying.get_record_info(parsed_host, :cname)

    case cname_res do
      [] ->
        a_res = DomainRecordQuerying.get_record_info(parsed_host, :a)

        case a_res do
          [] -> nil
          _ -> a_res
        end

      _ ->
        cname_res
    end
  end

  def construct_cname_dns_record(parent_domain, children_list, %{
        host: host,
        source: source,
        tool: tool
      })
      when is_list(children_list) do
    host_name =
      case get_host_name_without_domain(parent_domain, host) do
        {:ok, name} -> name
        {:error, _} -> nil
      end

    res = resolve_for_cname_or_a(host)

    case res do
      nil ->
        nil

      _ ->
        Enum.map(res, fn r -> construct_cname_record(r, host_name, source: source, tool: tool) end)
    end
  end

  defp construct_cname_record(record, host_name, options \\ []) do
    source = Keyword.get(options, :source, "")
    tool = Keyword.get(options, :tool, "")

    construct_dns_record(%{
      id: "#{record.domain}",
      name: "#{record.domain}",
      display_name: "#{DomainName.name(host_name)}",
      type: record.type,
      special_type: "",
      data: handle_subdomain_data(record.data),
      ttl: record.ttl,
      children: [],
      query_tool: tool,
      answer_source: source
    })
  end

  def get_host_name_without_domain(parent_domain, host) do
    DomainName.new!(host) |> DomainName.without_suffix(parent_domain)
  end

  def handle_subdomain_data(data) when is_tuple(data) do
    data
    |> Tuple.to_list()
    |> Enum.join(".")
  end

  def handle_subdomain_data(data), do: Kernel.to_string(data)

  def construct_dns_record(dns_record) when is_map(dns_record) do
    %DnsRecord{
      id: dns_record.id,
      name: dns_record.name,
      display_name: dns_record.display_name,
      type: dns_record.type,
      special_type: dns_record.special_type,
      priority: Map.get(dns_record, :priority, nil),
      data: dns_record.data,
      ttl: dns_record.ttl,
      children: dns_record.children,
      query_tool: Map.get(dns_record, :query_tool, ""),
      answer_source: Map.get(dns_record, :answer_source, "")
    }
  end
end
```

```elixir
### TO DELETE
test_res =
  DnsZoneTree.get_dkim_records(verified_domain, dkim_subdomain_label, known_dkim_selector_list)
```

```elixir
### TO DELETE
test_res
```

```elixir
### TO DELETE
zone_tree = DnsZoneTree.construct_zone_tree(verified_domain, dmarc_subdomain_label)
```

Reaching in to each map, we can take out the value for each `host` key, returning a simple list of strings.

```elixir
subdomain_list =
  enumerated_subdomains
  |> Enum.map(fn %{host: host} -> host end)
```

What we've now got is a list of subdomains, with fully-qualified domain names (FQDN). This is very wordy, as each subdomain is fully specified, containing the domain name in full. We don't want that much information, stripping the zone parent domain name from each subdomain, leaving only the actual subdomain name itself.

```elixir
subdomains =
  subdomain_list
  |> Enum.map(fn d ->
    d
    |> DomainName.new!()
    |> DomainName.without_suffix(verified_domain)
    |> case do
      {:ok, s} -> DomainName.name(s)
    end
  end)
  |> Enum.filter(fn i -> i != "" end)
```

As it will be necessary later, in the diagram generation and styling stage, let's calculate how many nodes we need to diagram, saving it into the `number_of_relationships` variable.

## Visualising the DNS zone

With the information now gathered, we can create a usable flowchart diagram, presenting the zone visually. We will use [Mermaid](https://mermaid.js.org/) for this, as it is an easy to use tool for programmatic diagram creation.

<!-- livebook:{"break_markdown":true} -->

To begin with, let's define invariant sections of the diagram definition: initialisation configuration, diagram type and title, and styling. By doing this up front, we're developing the diagram definition in easily managable segments, and defining the diagram in a _literate programming_ style.

```elixir
dns_zone_diagram_configuration =
  """
  %%{ init: { 
    'theme': 'base',
    'themeVariables': {
      'clusterBkg': '#81a1c144;'
    },
    'fontFamily': 'Calluna Sans, Helvetica, Trebuchet MS, Verdana, Arial, Sans-Serif',
    'flowchart': { 
      'curve': 'linear',
      'useMaxWidth': 'true'
     } 
    } }%%
  """
```

```elixir
diagram_type = "flowchart LR"
```

In the following step, we insert the list of edges by order of definition.

```elixir
diagram_styles =
  """
  classDef parent-node fill:turquoise,stroke:#b48ead,stroke-width:1px;
  classDef parent-zone fill:#81a1c144,stroke:#b48ead,stroke-width:1px;
  classDef cname-record fill:#88c0d088,stroke:#b48ead,stroke-width:1px;
  classDef ns-record fill:#bf616a44,stroke:#b48ead,stroke-width:1px;
  classDef mx-record fill:#d0877099,stroke:#b48ead,stroke-width:1px;
  classDef txt-record fill:#ebcb8b88,stroke:#b48ead,stroke-width:1px;
  classDef a-record fill:#a3be8c99,stroke:#b48ead,stroke-width:1px;
  """
```

First, we need a module, `ZoneTree` to convert this data into Mermaid flowchart definition code.

```elixir
defmodule ZoneTree do
  def define_parent_node(parent_domain) do
    strf_format_string = "%Y-%m-%d"

    domain_critical_info = DomainNameQuerying.get_critical_domain_info(parent_domain)
    date_created = domain_critical_info.created_at |> Calendar.strftime(strf_format_string)
    date_updated = domain_critical_info.updated_at |> Calendar.strftime(strf_format_string)
    date_expires = domain_critical_info.expires_at |> Calendar.strftime(strf_format_string)

    "parent-node([\"`#{DomainName.name(parent_domain)}
    —
    Created #{date_created}
    Updated #{date_updated}
    Expiry #{date_expires}`\"]):::parent-node;"
  end

  def define_dns_zone(parent_domain, dmarc_subdomain_label) do
    zone_tree = DnsZoneTree.construct_zone_tree(parent_domain, dmarc_subdomain_label)

    zone_records =
      for rec <- zone_tree do
        "parent-node #{define_link_type(rec.type)} #{rec.id}([\"`#{rec.display_name} 
        —
        TTL #{rec.ttl}
        #{if rec.type === :mx, do: rec.priority} #{rec.data}`\"])#{attach_style_class(rec.type)}"
      end

    zone_records
    |> Enum.join(";")
  end

  def define_dns_sub_zones(parent_domain, subdomain_list) do
    zone_tree = DnsZoneTree.construct_cname_zone_trees(parent_domain, subdomain_list)

    zone_records =
      for rec <- zone_tree do
        "parent-node #{define_link_type(rec.type)} #{rec.id}([\"`#{rec.display_name} #{if rec.type === :mx, do: ": " <> rec.name}
        —
        TTL #{rec.ttl}
        #{if rec.type === :mx, do: rec.priority} #{rec.data}`\"])#{attach_style_class(rec.type)}"
      end

    zone_records
    |> Enum.join(";")
  end

  def define_link_type(type) when is_atom(type) do
    case type do
      :a -> "----"
      :ns -> "-.-"
      :mx -> "---"
      :txt -> "---"
      :cname -> "-----"
      _ -> "---"
    end
  end

  def attach_style_class(type) when is_atom(type) do
    case type do
      :a -> ":::a-record"
      :ns -> ":::ns-record"
      :mx -> ":::mx-record"
      :txt -> ":::txt-record"
      :cname -> ":::cname-record"
      _ -> ""
    end
  end

  def enumerate_relationships(zone_tree) do
    edges =
      for i <- 0..(length(zone_tree) - 1) do
        "#{i}"
      end

    Enum.join(edges, ",")
  end
end
```

The `construct_tree/1` function takes the parent domain and the list of subdomains, converting them to a node-and-relationship definition string.

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
parent_node = ZoneTree.define_parent_node(verified_domain)

parent_zone =
  """
  subgraph parent-zone [#{DomainName.name(verified_domain)} zone];
    direction LR;
    #{ZoneTree.define_dns_zone(verified_domain, dmarc_subdomain_label)};
  end;
  """

zones =
  ZoneTree.define_dns_sub_zones(verified_domain, enumerated_subdomains)
```

Feeding this definition string into the scaffolded diagram definition provides us with the complete diagram definition.

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
dns_zone_diagram =
  """
  #{dns_zone_diagram_configuration}
  #{diagram_type};
  #{parent_node}
  #{parent_zone}
  #{zones}
  #{diagram_styles}
  """
```

The diagram definition, stored in the `dns_zone_diagram` variable, can now be used to draw the DNS zone diagram.

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
Kino.Mermaid.new(dns_zone_diagram)
```

## Audit summary and advice

```elixir
Kino.Markdown.new("""
### BIMI

#{Enum.join(bimi_advice, "\n\n")}


### DKIM

#{Enum.join(dkim_advice, "\n\n")}

**DKIM record** _`#{String.slice(dkim_scan_result, 0..60)}...`_


### DMARC

#{Enum.join(dmarc_advice, "\n\n")}

**DMARC record** _`#{dmarc_scan_result}`_

### Domain

#{Enum.join(domain_advice, "\n\n")}


### MX

#{Enum.join(mx_advice, "\n\n")}


### SPF

#{Enum.join(spf_advice, "\n\n")}

**SPF record** _`#{spf_scan_result}`_
""")
```
