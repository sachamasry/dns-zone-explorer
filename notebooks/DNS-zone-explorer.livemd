<!-- livebook:{"autosave_interval_s":60} -->

# DNS Zone Explorer

```elixir
Mix.install([
  {:kino, "~> 0.12.3"},
  {:kino_shell, "~> 0.1.2"},
  {:jason, "~> 1.4"},
  {:domainname, "~> 0.1.5"}
])
```

## Using Erlang's :inet_res builtin functionality

```elixir
{:ok, res} = :inet_res.resolve(~c"google.com", :in, :txt)

res
|> :inet_dns.msg()
|> Keyword.fetch!(:anlist)
|> Enum.map(fn n -> :inet_dns.rr(n) end)
```

## On DNS zone enumeration

For security reasons, it is difficult to get a true state of a DNS zone, as this is information which would be used by attackers in finding exploits.

To enumerate subdomains of a domain, we will turn to several penetration testing tools.

<!-- livebook:{"break_markdown":true} -->

Let's get locations of all subdomain enumeration tools we may need, into variables we can use.

```elixir
amass_binary = System.get_env("LB_AMASS_BIN")
assetfinder_binary = System.get_env("LB_ASSETFINDER_BIN")
dnsrecon_binary = System.get_env("LB_DNSRECON_BIN")
puredns_binary = System.get_env("LB_PUREDNS_BIN")
subfinder_binary = System.get_env("LB_SUBFINDER_BIN")
sublist3r_binary = System.get_env("LB_SUBLIST3R_BIN")
:ok
```

Next, we need user input to know which domain to enumerate, saving the input into the `domain` variable.

```elixir
domain = Kino.Input.text("Enter your domain name")
```

The following will read and attempt to construct a valid domain name and parrot the user input back to us, as a simple form of feedback. If it fails, then an error will warn us of this at this stage.

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
{:ok, verified_domain} =
  DomainName.new(Kino.Input.read(domain),
    must_be_hostname: true
  )
```

We now call out to `System.cmd` to run `subfinder` on our domain. Note that ease of parsing is most important here, thus the tool is run with a few additional options:

* `-silent` so that the masthead message, progress and other messages are not printed to `stdout`
* `-json` to return a list of JSON-formatted results, for each enumerated subdomain
* `-active` to display active subdomains only

**PLEASE NOTE** This command is run on the network, querying multiple internet sources, and as such is likely to take some time, typically needing 30 seconds or more. Please be patient and don't interrupt it unnecessarily. For additional informative use, `stderr` has been redirected to `stdout` to show error messages, if any.

```elixir
{subfinder_query_result, 0} =
  System.cmd(
    "bash",
    ["-lc", "#{subfinder_binary} -d #{DomainName.name(verified_domain)} -silent -json -active"],
    stderr_to_stdout: true
  )
```

With query results saved to `subfinder_query_results`, we now need to clean up the results by splitting away newline characters (`\n`), filtering out empty strings, and parsing the JSON results.

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
enumerated_subdomains =
  subfinder_query_result
  |> String.split("\n")
  |> Enum.filter(fn i -> i != "" end)
  |> Enum.map(fn i -> Jason.decode!(i) end)
```

Reaching in to each map, we can take out the value for each `host` key, returning a simple list of strings.

```elixir
subdomain_list =
  enumerated_subdomains
  |> Enum.map(fn %{"host" => host} -> host end)
```

What we've now got is a list of subdomains, with fully-qualified domain names (FQDN). This is very wordy, as each subdomain is fully specified, containing the domain name in full. We don't want that much information, stripping the zone parent domain name from each subdomain, leaving only the actual subdomain name itself.

```elixir
subdomains =
  subdomain_list
  |> Enum.map(fn d ->
    d
    |> DomainName.new!()
    |> DomainName.without_suffix(verified_domain)
    |> case do
      {:ok, s} -> DomainName.name(s)
    end
  end)
  |> Enum.filter(fn i -> i != "" end)
```

## Visualising the DNS zone

With the information now gathered, we can create a usable flowchart diagram, presenting the zone visually. We will use [Mermaid](https://mermaid.js.org/) for this, as it is an easy to use tool for programmatic diagram creation.

<!-- livebook:{"break_markdown":true} -->

To begin with, let's define invariant sections of the diagram definition: initialisation configuration, diagram type and title, and styling. By doing this up front, we're developing the diagram definition in easily managable segments, and defining the diagram in a _literate programming_ style.

```elixir
dns_zone_diagram_configuration =
  """
  %%{ init: { 
    'fontFamily': 'Calluna Sans, Helvetica, Trebuchet MS, Verdana, Arial, Sans-Serif',
    'flowchart': { 'curve': 'linear' } 
    } }%%
  """
```

```elixir
diagram_type = "flowchart TD"
```

```elixir
diagram_styles =
  """
  classDef parent-node fill:turquoise;
  classDef subdomain color:#222;
  """
```

First, we need a module, `ZoneTree` to convert this data into Mermaid flowchart definition code.

```elixir
defmodule ZoneTree do
  def construct_tree(subdomain_list) when is_list(subdomain_list) do
    for s <- subdomain_list, into: [] do
      "parent-node --> #{s}([#{s}]):::subdomain"
    end
  end

  def define_parent_node(parent_domain) do
    "parent-node([#{DomainName.name(parent_domain)}]):::parent-node;"
  end
end
```

The `construct_tree/1` function takes the parent domain and the list of subdomains, converting them to a node-and-relationship definition string.

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
parent_node = ZoneTree.define_parent_node(verified_domain)

nodes =
  ZoneTree.construct_tree(subdomains) |> Enum.join(";")
```

Feeding this definition string into the scaffolded diagram definition provides us with the complete diagram definition.

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
dns_zone_diagram =
  """
  #{dns_zone_diagram_configuration}
  #{diagram_type};
  #{parent_node}
  #{nodes}
  #{diagram_styles}
  """
```

The diagram definition, stored in the `dns_zone_diagram` variable, can now be used to draw the DNS zone diagram.

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
Kino.Mermaid.new(dns_zone_diagram)
```
